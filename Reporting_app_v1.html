<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reporting AGROSANA 2026</title>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.3.1/umd/react.development.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.3.1/umd/react-dom.development.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.28.4/babel.min.js"></script>
  <script src="https://fastly.jsdelivr.net/npm/lucide@0.513.0/dist/umd/lucide.js"></script>
  <script>window.lucide = window.lucide || { createIcons: function(){} };</script>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">

  <pre id="bootErrorPanel" style="display:none;position:fixed;inset:12px;overflow:auto;padding:12px;background:#111827;color:#F9FAFB;border-radius:10px;z-index:999999;white-space:pre-wrap;font-family:monospace;font-size:12px;"></pre>
  <script>
    (function(){
      function show(msg){ var el=document.getElementById('bootErrorPanel'); if(!el)return; el.style.display='block'; el.textContent+=msg+"\n"; }
      window.addEventListener('error',function(e){ show('ERROR: '+(e.message||e.type)); if(e&&e.error&&e.error.stack)show(e.error.stack); });
      window.addEventListener('unhandledrejection',function(e){ var r=e&&e.reason; show('PROMISE: '+(r&&(r.stack||r.message)?r.stack||r.message:String(r))); });
    })();
  </script>

  <div id="root"></div>

  <script>
    // Limpia el cache de Babel (sessionStorage) para forzar recompilacion al actualizar
    (function() {
      var keys = Object.keys(sessionStorage);
      keys.forEach(function(k) { if (k.indexOf('babel') !== -1 || k.indexOf('transform') !== -1) sessionStorage.removeItem(k); });
    })();
  </script>
  <script type="text/babel" data-build="20260227-v16">
    const { useState, useEffect, useCallback, useRef } = React;

    // ─── CONSTANTES ───────────────────────────────────────────────────────────

    const MESES = ['ene','feb','mar','abr','may','jun','jul','ago','sep','oct','nov','dic'];
    const MESES_LABEL = ['ene-26','feb-26','mar-26','abr-26','may-26','jun-26','jul-26','ago-26','sep-26','oct-26','nov-26','dic-26'];
    const MESES_HIST  = ['ene-25','feb-25','mar-25','abr-25','may-25','jun-25','jul-25','ago-25','sep-25','oct-25','nov-25','dic-25'];
    const EMPRESAS = ['Consolidado','AGS','AHL','FTP'];

    // Lineas del PyG (sin acentos ni caracteres especiales en las keys)
    const PYG_LINES = [
      { key:'ventas',      label:'Total Ventas',                              tipo:'total' },
      { key:'coste',       label:'(-) Coste Total',                           tipo:'coste' },
      { key:'margen',      label:'Margen Bruto',                              tipo:'subtotal' },
      { key:'pct_mb',      label:'(%) Ventas MB',                             tipo:'pct' },
      { key:'personal',    label:'(-) Gastos de personal',                    tipo:'coste' },
      { key:'opex',        label:'(-) Otros gastos de explotacion',           tipo:'coste' },
      { key:'deterioro',   label:'(-) Deterioro de credito comercial (0,4%)', tipo:'coste' },
      { key:'ebitda',      label:'EBITDA',                                    tipo:'subtotal' },
      { key:'pct_ebitda',  label:'(%) Ventas EBITDA',                        tipo:'pct' },
      { key:'amort',       label:'(-) Amortizaciones y otros resultados',     tipo:'coste' },
      { key:'ebit',        label:'EBIT',                                      tipo:'subtotal' },
      { key:'gtos_fin',    label:'(+/-) Ingresos/gastos financieros',         tipo:'coste' },
      { key:'no_rec',      label:'(-) Gastos no recurrentes',                 tipo:'coste' },
      { key:'dto_com',     label:'(+/-) Ingresos/gastos dto. comercial',      tipo:'otro' },
      { key:'bai',         label:'BAI',                                       tipo:'subtotal' },
      { key:'impuestos',   label:'(-) Impuestos',                             tipo:'coste' },
      { key:'bdi',         label:'BDI',                                       tipo:'subtotal' },
    ];

    // Lineas del BS
    const BS_LINES = [
      { key:'act_no_cor',   label:'Activo no Corriente',                              grupo:'activo',  nivel:1 },
      { key:'inmov',        label:'Inmovilizado material / Inmaterial',               grupo:'activo',  nivel:2 },
      { key:'inv_grupo_lp', label:'Inversiones en empresas del grupo LP',             grupo:'activo',  nivel:2 },
      { key:'inv_fin_lp',   label:'Inversiones financieras a largo plazo',            grupo:'activo',  nivel:2 },
      { key:'imp_dif_act',  label:'Activos por impuesto diferido',                    grupo:'activo',  nivel:2 },
      { key:'act_cor',      label:'Activo Corriente',                                 grupo:'activo',  nivel:1 },
      { key:'existencias',  label:'Existencias',                                      grupo:'activo',  nivel:2 },
      { key:'clientes',     label:'Clientes',                                         grupo:'activo',  nivel:2 },
      { key:'imp_cor_act',  label:'Activos por impuesto corriente',                   grupo:'activo',  nivel:2 },
      { key:'otros_aapp',   label:'Otros creditos con las AAPP',                      grupo:'activo',  nivel:2 },
      { key:'inv_fin_cp',   label:'Inversiones financieras a corto plazo',            grupo:'activo',  nivel:2 },
      { key:'periodif',     label:'Periodificaciones a corto plazo',                  grupo:'activo',  nivel:2 },
      { key:'tesoreria',    label:'Tesoreria',                                        grupo:'activo',  nivel:2 },
      { key:'activo',       label:'ACTIVO',                                           grupo:'activo',  nivel:0 },
      { key:'ffpp',         label:'Fondos Propios',                                   grupo:'pasivo',  nivel:1 },
      { key:'otros_pas',    label:'Otros',                                            grupo:'pasivo',  nivel:2 },
      { key:'imp_dif_pas',  label:'Pasivos por impuesto diferido',                    grupo:'pasivo',  nivel:2 },
      { key:'deuda_fin',    label:'Deuda Financiera',                                 grupo:'pasivo',  nivel:1 },
      { key:'deuda_entid',  label:'Deudas con entidades de credito',                  grupo:'pasivo',  nivel:2 },
      { key:'otros_fin',    label:'Otros pasivos financieros/Deuda empr grupo',       grupo:'pasivo',  nivel:2 },
      { key:'acreedores',   label:'Acreedores Comerciales',                           grupo:'pasivo',  nivel:1 },
      { key:'proveedores',  label:'Proveedores/acreedores',                           grupo:'pasivo',  nivel:2 },
      { key:'aapp_imp',     label:'Administracion Publica. Imp sociedades',           grupo:'pasivo',  nivel:2 },
      { key:'pasivo',       label:'PASIVO',                                           grupo:'pasivo',  nivel:0 },
    ];

    // ─── UTILIDADES ───────────────────────────────────────────────────────────

    // Formato numerico: miles con punto, negativos entre parentesis
    function fmt(val, decimals = 0) {
      if (val === null || val === undefined || val === '' || isNaN(Number(val))) return '-';
      const n = Number(val);
      const abs = Math.abs(n).toLocaleString('es-ES', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
      return n < 0 ? '(' + abs + ')' : abs;
    }

    function fmtPct(val) {
      if (val === null || val === undefined || isNaN(Number(val))) return '-';
      const n = Number(val);
      return (n >= 0 ? '' : '') + n.toFixed(1).replace('.', ',') + '%';
    }

    function parseNum(str) {
      if (str === null || str === undefined || str === '') return 0;
      let s = String(str).trim();
      // Negativos entre parentesis: (4.737) -> -4737
      const neg = s.startsWith('(') && s.endsWith(')');
      if (neg) s = s.slice(1, -1).trim();
      // Eliminar prefijos de moneda y espacios
      s = s.replace(/^[€$\s]+/, '').replace(/[€$\s]+$/, '');
      if (s === '' || s === '-') return 0;

      const dots   = (s.match(/\./g) || []).length;
      const commas = (s.match(/,/g)  || []).length;
      let num;

      if (dots > 1) {
        // "1.234.567,89" o "1.234.567" → separador miles es punto
        s = s.replace(/\./g, '').replace(',', '.');
        num = parseFloat(s);
      } else if (dots === 1 && commas === 1) {
        // Determinar orden: "1,234.56" (ingles) o "1.234,56" (espanol)
        num = (s.indexOf(',') < s.indexOf('.'))
          ? parseFloat(s.replace(',', ''))          // ingles: quitar coma miles
          : parseFloat(s.replace('.', '').replace(',', '.')); // espanol
      } else if (dots === 0 && commas === 1) {
        // "1234,56" → decimal espanol o "1,234" → miles ingles
        const afterComma = s.split(',')[1] || '';
        num = (afterComma.length === 3)
          ? parseFloat(s.replace(',', ''))    // miles ingles: "1,234"
          : parseFloat(s.replace(',', '.'));  // decimal espanol: "1234,56"
      } else if (dots === 1 && commas === 0) {
        // "1.234" (miles espanol, 3 dig) o "1234.56" (decimal ingles)
        const afterDot = s.split('.')[1] || '';
        num = (afterDot.length === 3)
          ? parseFloat(s.replace('.', ''))   // miles espanol: "1.234" → 1234
          : parseFloat(s);                   // decimal ingles: "1234.56"
      } else {
        // Sin separadores: numero entero
        s = s.replace(/[^0-9\-]/g, '');
        num = parseFloat(s);
      }

      if (isNaN(num)) return 0;
      return neg ? -num : num;
    }

    // Lee una hoja de xlsx y devuelve array de arrays
    // Usa cell.w (texto formateado) para que las fechas como "dic.-25" sean legibles
    function sheetToArray(ws) {
      const ref = ws['!ref'];
      if (!ref) return [];
      const range = XLSX.utils.decode_range(ref);
      const rows = [];
      for (let r = range.s.r; r <= range.e.r; r++) {
        const row = [];
        for (let c = range.s.c; c <= range.e.c; c++) {
          const cell = ws[XLSX.utils.encode_cell({ r, c })];
          if (!cell) { row.push(''); continue; }
          // Prioridad: texto formateado (w) > valor raw (v)
          if (cell.w !== undefined) row.push(cell.w);
          else if (cell.v !== undefined) row.push(cell.v);
          else row.push('');
        }
        rows.push(row);
      }
      return rows;
    }

    // ─── PLANTILLAS EXCEL ─────────────────────────────────────────────────────

    function downloadXlsx(wb, filename) {
      const buf = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
      const blob = new Blob([buf], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    // Plantilla PyG: CONCEPTO + ene..dic, filas de datos (sin subtotales ni porcentajes)
    function makePygWb(sheetName) {
      const wb = XLSX.utils.book_new();
      const headers = ['CONCEPTO', ...MESES];
      const dataRows = PYG_LINES
        .filter(l => l.tipo !== 'pct' && l.tipo !== 'subtotal')
        .map(l => [l.label, ...Array(12).fill(0)]);
      const ws = XLSX.utils.aoa_to_sheet([headers, ...dataRows]);
      ws['!cols'] = [{ wch: 45 }, ...Array(12).fill({ wch: 10 })];
      XLSX.utils.book_append_sheet(wb, ws, sheetName);
      return wb;
    }

    // Plantilla BS: CONCEPTO + columnas dadas (p.ej. ['dic-25'] o ['ene'..'dic'] o ambas)
    function makeBsWb(sheetName, cols) {
      const wb = XLSX.utils.book_new();
      const headers = ['CONCEPTO', ...cols];
      const dataRows = BS_LINES.map(l => [l.label, ...Array(cols.length).fill(0)]);
      const ws = XLSX.utils.aoa_to_sheet([headers, ...dataRows]);
      ws['!cols'] = [{ wch: 45 }, ...Array(cols.length).fill({ wch: 12 })];
      XLSX.utils.book_append_sheet(wb, ws, sheetName);
      return wb;
    }

    // Plantilla generica: CONCEPTO + ene..dic, con filas de ejemplo editables
    function makeSimpleWb(sheetName, exampleRows) {
      const wb = XLSX.utils.book_new();
      const headers = ['CONCEPTO', ...MESES];
      const dataRows = exampleRows.map(label => [label, ...Array(12).fill(0)]);
      const ws = XLSX.utils.aoa_to_sheet([headers, ...dataRows]);
      ws['!cols'] = [{ wch: 40 }, ...Array(12).fill({ wch: 10 })];
      XLSX.utils.book_append_sheet(wb, ws, sheetName);
      return wb;
    }

    function getTemplate(storageKey) {
      const MES12 = [...MESES];
      const OPEX_EX = ['Alquiler', 'Suministros', 'Servicios profesionales', 'Otros gastos'];
      switch (storageKey) {
        case 'pygHist':   return { wb: makePygWb('PyG'),                              name: 'plantilla_pyg_hist_2025.xlsx' };
        case 'pygPpto':   return { wb: makePygWb('PyG'),                              name: 'plantilla_pyg_ppto_2026.xlsx' };
        case 'pygReal':   return { wb: makePygWb('PyG'),                              name: 'plantilla_pyg_real_2026.xlsx' };
        case 'bsHist':    return { wb: makeBsWb('BS', MES12),                         name: 'plantilla_bs_hist_2025.xlsx' };
        case 'bsPpto':    return { wb: makeBsWb('BS', MES12),                         name: 'plantilla_bs_ppto_2026.xlsx' };
        case 'bsReal':    return { wb: makeBsWb('BS', MES12),                         name: 'plantilla_bs_real_2026.xlsx' };
        case 'opexHist':  return { wb: makeSimpleWb('OPEX', OPEX_EX),                 name: 'plantilla_opex_hist_2025.xlsx' };
        case 'opexPpto':  return { wb: makeSimpleWb('OPEX', OPEX_EX),                 name: 'plantilla_opex_ppto_2026.xlsx' };
        case 'opexReal':  return { wb: makeSimpleWb('OPEX', OPEX_EX),                 name: 'plantilla_opex_real_2026.xlsx' };
        case 'capexReal': return { wb: makeSimpleWb('CAPEX', ['Maquinaria', 'Instalaciones', 'Equipos']), name: 'plantilla_capex_real_2026.xlsx' };
        case 'dfnReal':   return { wb: makeSimpleWb('DFN',   ['Deuda LP', 'Deuda CP', 'Tesoreria']),      name: 'plantilla_dfn_real_2026.xlsx' };
        case 'norecReal': return { wb: makeSimpleWb('NoRec', ['Reestructuracion', 'Litigios', 'Otros']), name: 'plantilla_norec_real_2026.xlsx' };
        default: return null;
      }
    }

    // ─── STORAGE ──────────────────────────────────────────────────────────────

    const STORAGE_KEYS = {
      pygHist:    'rep_pyg_hist',
      pygPpto:    'rep_pyg_ppto',
      bsHist:     'rep_bs_hist',
      bsPpto:     'rep_bs_ppto',
      norecPpto:  'rep_norec_ppto',
      opexHist:   'rep_opex_hist',
      opexPpto:   'rep_opex_ppto',
      pygReal:    'rep_pyg_real',
      bsReal:     'rep_bs_real',
      norecReal:  'rep_norec_real',
      opexReal:   'rep_opex_real',
      capexReal:  'rep_capex_real',
      dfnReal:    'rep_dfn_real',
    };

    function loadFromStorage(key) {
      try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : null; } catch { return null; }
    }
    function saveToStorage(key, data) {
      try { localStorage.setItem(key, JSON.stringify(data)); } catch(e) { console.error('Storage error', e); }
    }
    function clearStorage(key) {
      try { localStorage.removeItem(key); } catch {}
    }

    // ─── PARSERS DE EXCEL ──────────────────────────────────────────────────────

    // Detecta la fila de cabecera buscando celdas que contengan mes+anio juntos (ej: "ene.-26")
    // Requiere al menos 3 celdas con mes+anio para evitar filas de etiquetas ("Historico/Real")
    function findHeaderRow(rows, mesLabels) {
      const yr = mesLabels[0]?.substring(mesLabels[0].indexOf('-') + 1) || '26';
      // Paso 1: fila con >= 3 celdas que tengan mes+anio en la misma celda
      for (let r = 0; r < Math.min(rows.length, 25); r++) {
        let conAnio = 0;
        for (let c = 0; c < rows[r].length; c++) {
          const v = String(rows[r][c]).toLowerCase().trim();
          const hasMes = MESES.some(m => v.includes(m));
          const hasYr  = v.includes(yr) || v.includes('20' + yr);
          if (hasMes && hasYr) conAnio++;
        }
        if (conAnio >= 3) return r;
      }
      // Fallback: primera fila con cualquier mes conocido
      for (let r = 0; r < rows.length; r++) {
        for (let c = 0; c < rows[r].length; c++) {
          const v = String(rows[r][c]).toLowerCase().trim();
          if (mesLabels.some(m => v.includes(m.toLowerCase().replace('-', '').substring(0, 3)))) return r;
        }
      }
      return -1;
    }

    // Detecta columnas de meses buscando la secuencia consecutiva MAS A LA IZQUIERDA.
    // Estrategia principal: primer grupo de 12 meses consecutivos (sin requerir ano).
    // Esto evita coger secciones de otras empresas (AGS, AHL, FTP) que aparecen
    // mas a la derecha y SI tienen el ano en la cabecera.
    function findMonthCols(headerRow, mesLabels) {
      const yr = mesLabels[0]?.substring(mesLabels[0].indexOf('-') + 1) || '26';
      // Meses en español e inglés para detectar cabeceras en ambos idiomas
      const EN_MESES = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];

      // Paso 1: busca la secuencia leftmost de 12 meses consecutivos (sin requerir ano)
      for (let startC = 0; startC < headerRow.length - 11; startC++) {
        const v0 = String(headerRow[startC]).toLowerCase().trim();
        // El primer mes debe empezar con 'ene' (español) o 'jan' (inglés)
        const esEne = v0.startsWith('ene') || (v0.includes('ene') && (v0.includes('.') || v0.includes('-')));
        const esJan = v0.startsWith('jan') || (v0.includes('jan') && (v0.includes('.') || v0.includes('-')));
        if (!esEne && !esJan) continue;
        // Intenta encontrar los 12 meses en orden a partir de startC
        const candidate = { 0: startC };
        let prev = startC;
        let ok = true;
        for (let i = 1; i < 12; i++) {
          let found = false;
          for (let c = prev + 1; c <= prev + 4 && c < headerRow.length; c++) {
            const v = String(headerRow[c]).toLowerCase().trim();
            const matchEs = v.startsWith(MESES[i]) || v.includes(MESES[i] + '.') || v.includes(MESES[i] + '-');
            const matchEn = v.startsWith(EN_MESES[i]) || v.includes(EN_MESES[i] + '.') || v.includes(EN_MESES[i] + '-');
            if (matchEs || matchEn) {
              candidate[i] = c; prev = c; found = true; break;
            }
          }
          if (!found) { ok = false; break; }
        }
        if (ok) {
          console.log('[findMonthCols] Secuencia encontrada en col', startC, '| cols:', JSON.stringify(candidate));
          return candidate;
        }
      }

      // Paso 2 (fallback): busca mes+ano por celda (util si cada seccion tiene el ano)
      const EN_MESES2 = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
      const cols = {};
      mesLabels.forEach((label, idx) => {
        const mes = label.substring(0, 3).toLowerCase();  // español
        const mesEn = EN_MESES2[idx];                     // inglés
        for (let c = 0; c < headerRow.length; c++) {
          const v = String(headerRow[c]).toLowerCase().trim();
          const hasYr = v.includes(yr) || v.includes('20' + yr);
          if ((v.includes(mes) || v.includes(mesEn)) && hasYr) { cols[idx] = c; break; }
        }
        if (cols[idx] === undefined) {
          const usadas = new Set(Object.values(cols));
          for (let c = 0; c < headerRow.length; c++) {
            if (usadas.has(c)) continue;
            const v = String(headerRow[c]).toLowerCase().trim();
            if (v.startsWith(mes) || v === mes || v.startsWith(mesEn) || v === mesEn) { cols[idx] = c; break; }
          }
        }
      });
      console.log('[findMonthCols] Fallback cols:', JSON.stringify(cols));
      return cols;
    }

    // Detecta la columna de labels buscando la que produce MAS coincidencias con matchFn.
    // Mucho mas robusto que contar texto: solo cuenta si el label REALMENTE corresponde
    // a una linea conocida del informe.
    function findLabelCol(rows, headerRow, matchFn) {
      const maxCol = 15;
      const counts = {};
      for (let r = headerRow + 1; r < Math.min(rows.length, headerRow + 50); r++) {
        for (let c = 0; c < Math.min(maxCol, rows[r].length); c++) {
          const v = String(rows[r][c] || '').trim();
          if (!v || v.length < 3) continue;
          const matched = matchFn ? matchFn(v) : (v.length > 3 && isNaN(Number(v.replace(/\./g,'').replace(',','.'))));
          if (matched) counts[c] = (counts[c] || 0) + 1;
        }
      }
      const best = Object.entries(counts).sort((a, b) => b[1] - a[1])[0];
      const result = parseInt(best?.[0] ?? 0);
      console.log('[findLabelCol] Puntuaciones por col:', JSON.stringify(counts), '| elegido:', result);
      return result;
    }

    // Mapea labels del Excel a keys del PYG_LINES por similitud
    // Los checks especificos van ANTES de los generales para evitar falsos positivos
    function matchPygLine(label) {
      const l = label.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').trim();
      // 1. Porcentajes primero (mas especificos)
      if (l.includes('ebitda') && (l.includes('%') || l.includes('porcentaje') || l.startsWith('(%'))) return 'pct_ebitda';
      if ((l.includes('mb') || l.includes('margen')) && (l.includes('%') || l.startsWith('(%'))) return 'pct_mb';
      // 2. Coste ANTES de ventas para no confundir "Coste de las ventas" con ventas
      if (l.includes('coste') || l.includes('costo')) return 'coste';
      // 3. Ventas — excluir filas con %, con coste, y "no operativos" (que contiene 'ingres')
      //    Reconoce: "Total Ventas", "Importe neto de la cifra de negocios", "Ingresos de explotacion"
      if (!l.includes('%') && (
        l.includes('venta') ||
        l.includes('cifra de negocio') ||
        (l.includes('ingres') && !l.includes('financier') && !l.includes('dto') && !l.includes('no operat'))
      )) return 'ventas';
      // 4. Resto de lineas
      if (l.includes('margen') && !l.includes('%')) return 'margen';
      if (l.includes('personal') || l.includes('sueldo')) return 'personal';
      // Reconoce: "Otros gastos de explotacion", "Gastos generales" (4.b)
      if (l.includes('otros gastos') || l.includes('gastos generales') || l.includes('explotac')) return 'opex';
      // Reconoce: "Deterioro del credito comercial" (4.d)
      if (l.includes('deterioro') || l.includes('credito comercial')) return 'deterioro';
      if (l.includes('ebitda') && !l.includes('%')) return 'ebitda';
      if (l.includes('amort')) return 'amort';
      // BAI antes de EBIT para no confundir "BFO ANTES DE IMPUESTOS (BAI)" con EBIT
      // Reconoce: "BAI", "Antes de impuestos", "BFO ANTES DE IMPUESTOS (BAI)" (8.)
      if (l.includes('bai') || l.includes('antes de impuesto') || (l.includes('bfo') && l.includes('impuesto'))) return 'bai';
      if ((l.includes('ebit') || l.includes('bfo')) && !l.includes('ebitda')) return 'ebit';
      // Reconoce: "Ingresos/gastos financieros", "Ingresos y gastos no operativos" (7.)
      if (l.includes('financier') && (l.includes('ingreso') || l.includes('gasto'))) return 'gtos_fin';
      if (l.includes('no operativ') || l.includes('no operat')) return 'gtos_fin';
      if (l.includes('no recurrente') || l.includes('no recur')) return 'no_rec';
      if (l.includes('dto') && l.includes('comercial')) return 'dto_com';
      if (l.includes('impuesto') || l.includes('irpf')) return 'impuestos';
      if (l.includes('bdi') || l.includes('resultado') || l.includes('beneficio neto')) return 'bdi';
      return null;
    }

    // Parsea un Excel de PyG Evol (12 meses en columnas, lineas en filas)
    // mesLabels: array de 12 strings de mes a buscar
    // Devuelve: { ventas: [v1..v12], coste: [...], ... }
    function parsePygEvol(wb, sheetName, mesLabels) {
      const ws = wb.Sheets[sheetName];
      if (!ws) return null;
      const rows = sheetToArray(ws);
      const headerIdx = findHeaderRow(rows, mesLabels);
      console.log('[parsePygEvol] headerIdx:', headerIdx);
      if (headerIdx < 0) { console.log('[parsePygEvol] NO SE ENCONTRO CABECERA'); return null; }
      // Log de las primeras 20 celdas de la fila de cabecera para diagnostico
      console.log('[parsePygEvol] Fila cabecera (primeras 20 celdas):', rows[headerIdx].slice(0, 20));
      const monthCols = findMonthCols(rows[headerIdx], mesLabels);
      const labelCol = findLabelCol(rows, headerIdx, matchPygLine);
      console.log('[parsePygEvol] monthCols:', JSON.stringify(monthCols), '| labelCol:', labelCol);
      // Log de las primeras 5 filas de datos para diagnostico
      for (let dbg = headerIdx + 1; dbg <= headerIdx + 5 && dbg < rows.length; dbg++) {
        console.log('[parsePygEvol] Fila dato', dbg, '- label[col', labelCol, ']:', rows[dbg][labelCol], '| mes0[col', monthCols[0], ']:', rows[dbg][monthCols[0]]);
      }
      const result = {};
      for (let r = headerIdx + 1; r < rows.length; r++) {
        const label = String(rows[r][labelCol] || '').trim();
        if (!label) continue;
        const key = matchPygLine(label);
        if (!key) continue;
        // First-occurrence wins: la primera seccion (Consolidado) no debe ser sobreescrita
        // por secciones de empresas individuales (AGS, AHL, FTP) que aparecen despues
        if (result[key]) continue;
        const vals = MESES.map((_, idx) => {
          const c = monthCols[idx];
          return c !== undefined ? parseNum(rows[r][c]) : 0;
        });
        console.log('[parsePygEvol] match row', r, '| key:', key, '| val[0]:', vals[0]);
        result[key] = vals;
      }
      return result;
    }

    // Mapea labels del Excel a keys del BS_LINES
    function matchBsLine(label) {
      const l = label.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').trim();
      if (l === 'activo no corriente' || l.includes('activo no corr')) return 'act_no_cor';
      if (l.includes('inmovilizado')) return 'inmov';
      if (l.includes('inversiones') && l.includes('grupo') && (l.includes('largo') || l.endsWith(' lp') || l.includes(' lp '))) return 'inv_grupo_lp';
      if (l.includes('inversiones') && l.includes('largo') && !l.includes('grupo')) return 'inv_fin_lp';
      if (l.includes('impuesto diferido') && l.includes('activ')) return 'imp_dif_act';
      if (l === 'activo corriente' || l.includes('activo corr')) return 'act_cor';
      if (l.includes('existencia')) return 'existencias';
      if (l.includes('cliente')) return 'clientes';
      if (l.includes('impuesto corriente') && l.includes('activ')) return 'imp_cor_act';
      if (l.includes('aapp') || l.includes('administraciones') && l.includes('credito')) return 'otros_aapp';
      if (l.includes('inversiones') && l.includes('corto') && !l.includes('grupo')) return 'inv_fin_cp';
      if (l.includes('periodif')) return 'periodif';
      if (l.includes('tesorer')) return 'tesoreria';
      if (l === 'activo') return 'activo';
      if (l.includes('fondos propios') || l.includes('patrimonio')) return 'ffpp';
      if (l.includes('impuesto diferido') && l.includes('pasiv')) return 'imp_dif_pas';
      if ((l.includes('otros') || l.includes('pasivos')) && !l.includes('financier') && !l.includes('corriente')) return 'otros_pas';
      if (l.includes('deuda financiera') && !l.includes('entidad') && !l.includes('otros')) return 'deuda_fin';
      if (l.includes('entidades de credito') || l.includes('entidades de cr')) return 'deuda_entid';
      if ((l.includes('otros pasivos') || l.includes('deuda empr')) && l.includes('financier')) return 'otros_fin';
      if (l.includes('acreedores comerciales')) return 'acreedores';
      if (l.includes('proveedor')) return 'proveedores';
      if (l.includes('administracion') && l.includes('imp')) return 'aapp_imp';
      if (l === 'pasivo') return 'pasivo';
      return null;
    }

    // Parsea formato plano: Gr. Balance Nivel 3|2|1 | Mes | ene | feb | ... | dic
    // Devuelve: { hist: {key: 0...}, real: {key: [v1..v12]} }
    function parseBsEvolFlat(rows) {
      const norm = s => String(s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').trim();
      // Buscar fila de cabecera con >= 6 meses del array MESES
      let headerIdx = -1;
      const monthCols = {};
      for (let r = 0; r < Math.min(rows.length, 5); r++) {
        let cnt = 0; const tmp = {};
        for (let c = 0; c < rows[r].length; c++) {
          const mi = MESES.indexOf(norm(rows[r][c]));
          if (mi >= 0 && tmp[mi] === undefined) { tmp[mi] = c; cnt++; }
        }
        if (cnt >= 6) { headerIdx = r; Object.assign(monthCols, tmp); break; }
      }
      if (headerIdx < 0) { console.log('[parseBsEvolFlat] cabecera no encontrada'); return null; }
      console.log('[parseBsEvolFlat] headerIdx:', headerIdx, 'monthCols:', monthCols);

      function matchFlat(c1, c2, c3) {
        const n1 = norm(c1), n2 = norm(c2), n3 = norm(c3);
        if (n1 === 'activo' && n2 === 'totales') return 'activo';
        if (n2.includes('activo no corriente')) {
          if (n3 === 'totales') return 'act_no_cor';
          if (n3.includes('inmovilizado')) return 'inmov';
          if (n3.includes('inversiones') && n3.includes('largo') && n3.includes('grupo')) return 'inv_grupo_lp';
          if (n3.includes('inversiones') && n3.includes('largo')) return 'inv_fin_lp';
          if (n3.includes('impuesto')) return 'imp_dif_act';
        }
        if (n2.includes('activo corriente')) {
          if (n3 === 'totales') return 'act_cor';
          if (n3.includes('existencias')) return 'existencias';
          if (n3.includes('deudores') || n3.includes('cuentas a cobrar')) return 'clientes';
          if (n3.includes('inversiones') && n3.includes('corto') && !n3.includes('grupo')) return 'inv_fin_cp';
          if (n3.includes('periodificaciones')) return 'periodif';
          if (n3.includes('efectivo')) return 'tesoreria';
        }
        if (n1 === 'pasivo' && n2 === 'totales') return 'pasivo';
        if (n2.includes('patrimonio')) {
          if (n3 === 'totales' || n3.includes('fondos propios')) return 'ffpp';
        }
        if (n2.includes('pasivo no corriente')) {
          if (n3 === 'totales') return null;
          if (n3.includes('deudas a largo')) return 'deuda_fin';
          if (n3.includes('impuesto')) return 'imp_dif_pas';
        }
        if (n2.includes('pasivo corriente')) {
          if (n3 === 'totales') return null;
          if (n3.includes('deudas a corto') && !n3.includes('grupo')) return 'deuda_entid';
          if (n3.includes('deudas') && n3.includes('grupo')) return 'otros_fin';
          if (n3.includes('acreedores')) return 'proveedores'; // WC uses 'proveedores'
          if (n3.includes('proveedores')) return 'proveedores';
        }
        return null;
      }

      const hist = {};
      const real = {};
      BS_LINES.forEach(l => { hist[l.key] = 0; real[l.key] = Array(12).fill(0); });
      let matchedLines = 0;
      for (let r = headerIdx + 1; r < rows.length; r++) {
        const c1 = String(rows[r]?.[0] || '').trim();
        const c2 = String(rows[r]?.[1] || '').trim();
        const c3 = String(rows[r]?.[2] || '').trim();
        if (!c1 && !c2 && !c3) continue;
        const key = matchFlat(c1, c2, c3);
        if (!key) continue;
        matchedLines++;
        const isPasivo = norm(c1) === 'pasivo';
        MESES.forEach((_, idx) => {
          const c = monthCols[idx];
          if (c !== undefined) {
            const v = parseNum(rows[r][c]);
            // Negar pasivos negativos para convertir a valor absoluto
            real[key][idx] += (isPasivo && v < 0) ? -v : v;
          }
        });
      }
      console.log('[parseBsEvolFlat] lineas mapeadas:', matchedLines);
      return { hist, real };
    }

    // Parsea BS Evol: primera columna = historico (dic-X), luego 12 meses
    // Devuelve: { hist: {key: val}, real: {key: [v1..v12]} }
    function parseBsEvol(wb, sheetName) {
      const ws = wb.Sheets[sheetName];
      if (!ws) { console.log('[parseBsEvol] hoja no encontrada:', sheetName); return null; }
      const rows    = sheetToArray(ws);
      // Detectar formato plano (Gr. Balance Nivel 3 | ... | ene | feb | ...)
      const isFlat = rows.slice(0, 5).some(row =>
        row.some(v => String(v||'').toLowerCase().includes('gr.') && String(v||'').toLowerCase().includes('balance'))
      );
      if (isFlat) { console.log('[parseBsEvol] Formato plano detectado'); return parseBsEvolFlat(rows); }
      // Leer tambien con raw:false para obtener texto formateado de celdas de fecha
      const rowsTxt = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '', raw: false });

      const norm = s => String(s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,'').trim();

      // Detecta si una celda es una fecha mes/ano (soporta string, serial numerico y Date)
      const MES_MAP = { ene:0,feb:1,mar:2,abr:3,may:4,jun:5,jul:6,ago:7,sep:8,oct:9,nov:10,dic:11,
                        jan:0,apr:3,aug:7,dec:11 };
      function parseMesCell(v) {
        if (!v && v !== 0) return null;
        if (v instanceof Date) return { mesIdx: v.getMonth(), year: v.getFullYear() };
        const n = Number(v);
        if (!isNaN(n) && n >= 30000 && n <= 60000 && String(v).trim() !== '') {
          const d = new Date((n - 25569) * 86400000);
          return { mesIdx: d.getUTCMonth(), year: d.getUTCFullYear() };
        }
        const s = norm(v);
        if (!s) return null;
        for (const [abbr, idx] of Object.entries(MES_MAP)) {
          if (s.includes(abbr)) {
            const ym = s.match(/(\d{2,4})/);
            if (ym) {
              const y = parseInt(ym[1]);
              return { mesIdx: idx, year: y < 100 ? 2000 + y : y };
            }
          }
        }
        const dm = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
        if (dm) {
          const y = parseInt(dm[3]); const year = y < 100 ? 2000 + y : y;
          return { mesIdx: parseInt(dm[1]) - 1, year };
        }
        return null;
      }

      // Helper: cuenta celdas de fecha en una fila
      function countDateCells(r) {
        let cnt = 0;
        const len = Math.max(rows[r]?.length || 0, rowsTxt[r]?.length || 0);
        for (let c = 0; c < len; c++) {
          if (parseMesCell(rows[r]?.[c]) || parseMesCell(rowsTxt[r]?.[c])) cnt++;
        }
        return cnt;
      }

      // Estrategia 1: fila que contiene "Balance de Situacion" Y tiene celdas de fecha
      // (La fila titulo "BALANCE DE SITUACION-EVOLUCION" no tiene fechas y se salta)
      let headerIdx = -1;
      let labelCol  = -1;
      for (let r = 0; r < Math.min(rows.length, 25) && headerIdx < 0; r++) {
        if (countDateCells(r) < 2) continue; // descartar filas sin fechas
        for (let c = 0; c < (rows[r]?.length || 0); c++) {
          if (norm(rows[r][c]).includes('balance de situac')) { headerIdx = r; labelCol = c; break; }
        }
      }
      // Estrategia 2: fila con 2+ celdas de fecha (aunque no tenga "Balance de Situacion")
      if (headerIdx < 0) {
        for (let r = 0; r < Math.min(rows.length, 25); r++) {
          if (countDateCells(r) >= 2) { headerIdx = r; break; }
        }
      }
      console.log('[parseBsEvol] headerIdx:', headerIdx, 'labelCol:', labelCol);
      if (headerIdx < 0) return null;

      // Recopilar todas las columnas de fecha del header
      const allDateCols = [];
      for (let c = 0; c < rows[headerIdx].length; c++) {
        const m = parseMesCell(rows[headerIdx][c]) || parseMesCell(rowsTxt[headerIdx]?.[c]);
        if (m) allDateCols.push({ c, mesIdx: m.mesIdx, year: m.year });
      }
      // Determinar ano de datos (el mas frecuente / mayor)
      const yearCounts = {};
      allDateCols.forEach(x => { yearCounts[x.year] = (yearCounts[x.year] || 0) + 1; });
      const dataYear = Number(Object.entries(yearCounts).sort((a, b) => b[1] - a[1] || Number(b[0]) - Number(a[0]))[0]?.[0] || 0);
      // Asignar histCol (primer col con ano < dataYear) y monthCols
      let histCol = -1;
      const monthCols = {};
      allDateCols.forEach(({ c, mesIdx, year }) => {
        if (year < dataYear) { if (histCol < 0) histCol = c; }
        else { if (monthCols[mesIdx] === undefined) monthCols[mesIdx] = c; }
      });
      // Si no hay histCol, primera fecha col = hist
      if (histCol < 0 && allDateCols.length > 0) histCol = allDateCols[0].c;
      console.log('[parseBsEvol] dataYear:', dataYear, 'histCol:', histCol, 'monthCols:', monthCols);

      // Detectar labelCol si no se determino por "Balance de Situacion"
      if (labelCol < 0) labelCol = findLabelCol(rows, headerIdx, matchBsLine);
      console.log('[parseBsEvol] labelCol:', labelCol);

      const hist = {};
      const real = {};
      BS_LINES.forEach(l => { hist[l.key] = 0; real[l.key] = Array(12).fill(0); });

      let matchedLines = 0;
      for (let r = headerIdx + 1; r < rows.length; r++) {
        const label = String(rows[r][labelCol] || '').trim();
        if (!label) continue;
        const key = matchBsLine(label);
        if (!key) continue;
        matchedLines++;
        if (histCol >= 0) hist[key] = parseNum(rows[r][histCol]);
        MESES.forEach((_, idx) => {
          const c = monthCols[idx];
          if (c !== undefined) real[key][idx] = parseNum(rows[r][c]);
        });
      }
      console.log('[parseBsEvol] lineas BS mapeadas:', matchedLines);
      return { hist, real };
    }

    // Parsea plantilla simple mensual (NoRec, OPEX, CAPEX, DFN)
    // Devuelve: { concepto: [v1..v12], ..., _total: [v1..v12] }
    function parseMonthlySheet(wb, sheetName, mesLabels) {
      const ws = wb.Sheets[sheetName];
      if (!ws) return null;
      const rows = sheetToArray(ws);
      const headerIdx = findHeaderRow(rows, mesLabels);
      if (headerIdx < 0) return null;
      const monthCols = findMonthCols(rows[headerIdx], mesLabels);
      // Para hojas genéricas (NoRec, OPEX, etc.) no tenemos matchFn, usamos null (modo texto)
      const labelCol = findLabelCol(rows, headerIdx, null);
      const result = {};
      for (let r = headerIdx + 1; r < rows.length; r++) {
        const label = String(rows[r][labelCol] || '').trim();
        if (!label) continue;
        const vals = MESES.map((_, idx) => {
          const c = monthCols[idx];
          return c !== undefined ? parseNum(rows[r][c]) : 0;
        });
        result[label] = vals;
      }
      return result;
    }

    // Parsea la hoja "No recurrentes" con dos bloques: REALES y PRESUPUESTO.
    // Devuelve: { reales: { rows, gastos_gen, gastos_lab, total }, presupuesto: { rows, total } }
    function parseNoRecSheet(wb, sheetName, mesLabels) {
      const ws = wb.Sheets[sheetName];
      if (!ws) return null;
      const rows = sheetToArray(ws);

      // Encontrar fila de cabecera (texto con mes+anio o seriales de fecha Excel 2026)
      let headerIdx = findHeaderRow(rows, mesLabels);
      if (headerIdx < 0) {
        for (let r = 0; r < Math.min(rows.length, 15); r++) {
          let dateCount = 0;
          for (let c = 0; c < rows[r].length; c++) {
            const v = Number(rows[r][c]);
            if (v >= 46000 && v <= 46400 && String(rows[r][c]).trim() !== '') dateCount++;
          }
          if (dateCount >= 3) { headerIdx = r; break; }
        }
      }
      if (headerIdx < 0) return null;

      // Encontrar columnas de meses
      let monthCols = findMonthCols(rows[headerIdx], mesLabels);
      // Fallback: detectar por serial de fecha (Jan-Dec 2026)
      if (Object.keys(monthCols).length < 3) {
        const SERIALS = [46023,46054,46082,46113,46143,46174,46204,46235,46266,46296,46327,46357];
        for (let idx = 0; idx < 12; idx++) {
          for (let c = 0; c < rows[headerIdx].length; c++) {
            const v = Number(rows[headerIdx][c]);
            if (Math.abs(v - SERIALS[idx]) <= 1) { monthCols[idx] = c; break; }
          }
        }
      }

      // Encontrar columna de labels buscando keywords propias del NoRec
      const normalize = s => String(s || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').trim();
      const norecKw = ['gastos no recurrente', 'gastos generales', 'gastos laborales', 'total gastos'];
      let labelCol = -1;
      outer: for (let r = headerIdx + 1; r < Math.min(rows.length, headerIdx + 60); r++) {
        for (let c = 0; c < Math.min(rows[r].length, 12); c++) {
          if (norecKw.some(kw => normalize(rows[r][c]).includes(kw))) { labelCol = c; break outer; }
        }
      }
      if (labelCol < 0) labelCol = findLabelCol(rows, headerIdx, null);

      const result = {
        reales:      { rows: [], gastos_gen: null, gastos_lab: null, total: null },
        presupuesto: { rows: [], total: null },
      };
      let block = null;

      for (let r = headerIdx + 1; r < rows.length; r++) {
        const label = String(rows[r][labelCol] || '').trim();
        if (!label || label.length < 3) continue;
        const lc = normalize(label);

        // Detectar cabeceras de bloque (no se anaden como filas de datos)
        if (lc.includes('gastos no recurrente') || lc.includes('gtos no recurrente')) {
          block = (lc.includes('presupuesto') || lc.includes('ppto')) ? 'presupuesto' : 'reales';
          continue;
        }
        if (!block) continue;

        const vals = MESES.map((_, idx) => {
          const c = monthCols[idx];
          return c !== undefined ? parseNum(rows[r][c]) : 0;
        });

        let tipo = 'detail';
        if (lc.includes('total gastos no recurrente') || lc.includes('total gtos no recurrente')) {
          tipo = 'total';
          result[block].total = vals;
        } else if (lc === 'gastos generales' || lc.startsWith('gastos generales')) {
          tipo = 'subtotal';
          if (block === 'reales') result.reales.gastos_gen = vals;
        } else if (lc === 'gastos laborales' || lc.startsWith('gastos laborales')) {
          tipo = 'subtotal';
          if (block === 'reales') result.reales.gastos_lab = vals;
        }
        result[block].rows.push({ label, vals, tipo });
      }

      // Si no hay fila de total, calcular de subtotales
      if (!result.reales.total && (result.reales.gastos_gen || result.reales.gastos_lab)) {
        result.reales.total = MESES.map((_, i) =>
          (result.reales.gastos_gen?.[i] || 0) + (result.reales.gastos_lab?.[i] || 0)
        );
      }
      if (!result.reales.rows.length && !result.presupuesto.rows.length) return null;
      return result;
    }

    // ─── CALCULOS ──────────────────────────────────────────────────────────────

    // Calcula los % del PyG a partir de ventas
    // Soporta tanto arrays (vista EVOL) como numeros simples (vista MES/YTD)
    function calcPygPct(pyg) {
      if (!pyg || !pyg.ventas) return pyg;
      const out = { ...pyg };
      if (Array.isArray(pyg.ventas)) {
        out.pct_mb     = pyg.ventas.map((v, i) => v ? (pyg.margen?.[i]  || 0) / v : 0);
        out.pct_ebitda = pyg.ventas.map((v, i) => v ? (pyg.ebitda?.[i]  || 0) / v : 0);
      } else {
        out.pct_mb     = pyg.ventas ? (pyg.margen  || 0) / pyg.ventas : 0;
        out.pct_ebitda = pyg.ventas ? (pyg.ebitda  || 0) / pyg.ventas : 0;
      }
      return out;
    }

    // Ajusta pygReal incorporando datos de No Recurrentes:
    // - no_rec: total del bloque Reales del NoRec
    // - opex: suma GASTOS GENERALES (no recurrentes clasificados como opex)
    // - personal: suma GASTOS LABORALES (no recurrentes clasificados como personal)
    // - ebitda, ebit, bai, bdi se recalculan en cascada
    function getAdjustedPygReal(pygReal, norecReal) {
      if (!pygReal) return pygReal;
      if (!norecReal?.reales) return pygReal;
      const nr = norecReal.reales;
      if (!nr.total && !nr.gastos_gen && !nr.gastos_lab) return pygReal;

      const addArr = (a, b) => {
        if (!a && !b) return Array(12).fill(0);
        if (!a) return (b || []).slice();
        return a.map((v, i) => v + (b?.[i] || 0));
      };

      // CONVENCION DE SIGNOS: en el PyG los costes se almacenan como NEGATIVOS
      // (ej: opex=-171, personal=-393). Los valores del NoRec vienen POSITIVOS
      // desde la hoja Excel. Se niegan al aplicar para mantener coherencia.
      const neg = (arr) => arr ? arr.map(v => -v) : null;

      // opex y personal reciben el coste negado (se vuelven mas negativos)
      const adjOpex     = addArr(pygReal.opex,    neg(nr.gastos_gen));
      const adjPersonal = addArr(pygReal.personal, neg(nr.gastos_lab));
      // no_rec se guarda negativo para mostrarse como coste (entre parentesis)
      const adjNoRec    = neg(nr.total) || pygReal.no_rec || Array(12).fill(0);

      // Delta en valor absoluto (positivo): cuanto aumentan los costes
      const delta = MESES.map((_, i) => (nr.gastos_gen?.[i] || 0) + (nr.gastos_lab?.[i] || 0));
      // EBITDA y EBIT se reducen (mas negativos) por los costes annadidos
      const adjEbitda = pygReal.ebitda ? pygReal.ebitda.map((v, i) => v - delta[i]) : null;
      const adjEbit   = pygReal.ebit   ? pygReal.ebit.map((v, i) => v - delta[i])   : null;

      return {
        ...pygReal,
        opex:     adjOpex,
        personal: adjPersonal,
        no_rec:   adjNoRec,
        ...(adjEbitda && { ebitda: adjEbitda }),
        ...(adjEbit   && { ebit:   adjEbit }),
      };
    }

    // Suma YTD hasta el mes indicado (0-indexed)
    function ytd(arr, mesFin) {
      if (!arr) return 0;
      return arr.slice(0, mesFin + 1).reduce((a, b) => a + b, 0);
    }

    // Diferencia absoluta y relativa
    function dif(a, b) {
      return { abs: a - b, rel: b !== 0 ? (a - b) / Math.abs(b) : 0 };
    }

    // Calcula CF a partir de PyG + BS mensual
    function calcCF(pygReal, bsReal, bsHist, capex, dfn, mes) {
      if (!pygReal || !bsReal) return null;
      const m = mes; // indice 0-11

      function bsDelta(key) {
        const prev = m === 0 ? (bsHist?.[key] || 0) : (bsReal[key]?.[m-1] || 0);
        const curr = bsReal[key]?.[m] || 0;
        return curr - prev;
      }

      const ebitda   = pygReal.ebitda?.[m] || 0;
      const noRec    = pygReal.no_rec?.[m] || 0;
      const dtoComercial = pygReal.dto_com?.[m] || 0;
      const ebitdaPF = ebitda - noRec - dtoComercial;

      const dExist    = bsDelta('existencias');
      const dClientes = bsDelta('clientes');
      const dProv     = bsDelta('proveedores');
      const dPeriodif = bsDelta('periodif');
      const totalWC   = dExist + dClientes + dProv + dPeriodif;

      const dAAPP     = bsDelta('aapp_imp') + bsDelta('imp_cor_act');
      const fcOp      = ebitda + totalWC + dAAPP;

      const capexVal  = capex ? Object.values(capex).reduce((s, arr) => s + (arr[m] || 0), 0) : 0;
      const fcDisp    = fcOp - capexVal;

      const gtosFin   = pygReal.gtos_fin?.[m] || 0;
      const totalFin  = gtosFin;
      const fcRepago  = fcDisp + totalFin;

      const tesCurr   = bsReal.tesoreria?.[m] || 0;
      const tesPrev   = m === 0 ? (bsHist?.tesoreria || 0) : (bsReal.tesoreria?.[m-1] || 0);
      const varCaja   = tesCurr - tesPrev;

      return {
        ebitdaPF, noRec, dtoComercial, ebitda,
        dExist, dClientes, dProv, dPeriodif, totalWC,
        dAAPP, fcOp,
        capexVal, fcDisp,
        gtosFin, totalFin, fcRepago,
        varCaja, tesPrev, tesCurr,
      };
    }

    // ─── COMPONENTES UI ───────────────────────────────────────────────────────

    function Badge({ children, color = 'gray' }) {
      const colors = {
        gray:   'bg-gray-100 text-gray-700',
        green:  'bg-green-100 text-green-700',
        orange: 'bg-orange-100 text-orange-700',
        blue:   'bg-blue-100 text-blue-700',
        red:    'bg-red-100 text-red-700',
      };
      return <span className={'text-xs px-2 py-0.5 rounded-full font-medium ' + (colors[color]||colors.gray)}>{children}</span>;
    }

    function UploadButton({ label, storageKey, onLoaded, loaded, color = 'blue', onDownloadTemplate }) {
      const fileRef = useRef(null);
      const colors = {
        blue:   'border-blue-300 bg-blue-50 hover:bg-blue-100 text-blue-700',
        orange: 'border-orange-300 bg-orange-50 hover:bg-orange-100 text-orange-700',
        green:  'border-green-300 bg-green-50 hover:bg-green-100 text-green-700',
      };

      function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev) {
          try {
            const wb = XLSX.read(ev.target.result, { type: 'array' });
            onLoaded(wb, storageKey);
          } catch(err) {
            alert('Error al leer el archivo: ' + err.message);
          }
        };
        reader.readAsArrayBuffer(file);
        e.target.value = '';
      }

      return (
        <div className={'border-2 border-dashed rounded-lg p-3 ' + (colors[color]||colors.blue) + (loaded ? ' opacity-80' : '')}>
          <div className="flex items-center gap-2 cursor-pointer" onClick={() => fileRef.current.click()}>
            <input ref={fileRef} type="file" accept=".xlsx,.xls" className="hidden" onChange={handleFile} />
            <span className="text-lg">{loaded ? '✓' : '↑'}</span>
            <div>
              <div className="text-sm font-medium">{label}</div>
              {loaded && <div className="text-xs opacity-70">Cargado — click para reemplazar</div>}
            </div>
          </div>
          {onDownloadTemplate && (
            <button
              className="mt-1.5 text-xs text-gray-400 hover:text-gray-600 underline block"
              onClick={e => { e.stopPropagation(); onDownloadTemplate(storageKey); }}>
              Descargar plantilla
            </button>
          )}
        </div>
      );
    }

    function SectionTitle({ children }) {
      return <h2 className="text-lg font-bold text-gray-800 mb-4 pb-2 border-b-2 border-gray-200">{children}</h2>;
    }

    function TabBar({ tabs, active, onChange }) {
      return (
        <div className="flex gap-1 mb-4 bg-gray-100 p-1 rounded-lg w-fit">
          {tabs.map(t => (
            <button key={t} onClick={() => onChange(t)}
              className={'px-4 py-1.5 rounded-md text-sm font-medium transition-all ' +
                (active === t ? 'bg-white shadow text-blue-700' : 'text-gray-500 hover:text-gray-700')}>
              {t}
            </button>
          ))}
        </div>
      );
    }

    // Celda de tabla con color segun tipo
    function Td({ value, tipo = 'normal', align = 'right', className = '' }) {
      const base = 'px-3 py-1.5 text-sm tabular-nums ';
      const colors = {
        hist:     'text-blue-700',
        real:     'text-orange-600 font-medium',
        ppto:     'text-green-700',
        dif_pos:  'text-green-700',
        dif_neg:  'text-red-600',
        label:    'text-gray-800 font-medium',
        subtotal: 'text-gray-900 font-bold bg-gray-50',
        total:    'text-gray-900 font-bold bg-gray-100',
        pct:      'text-gray-500 italic',
      };
      return (
        <td className={base + (colors[tipo] || 'text-gray-700') + ' text-' + align + ' ' + className}>
          {value}
        </td>
      );
    }

    function TdDif({ abs, rel, positiveIsGood = true }) {
      const good = positiveIsGood ? abs >= 0 : abs <= 0;
      const tipo = abs === 0 ? 'normal' : good ? 'dif_pos' : 'dif_neg';
      return (
        <>
          <Td value={fmt(abs)} tipo={tipo} />
          <Td value={fmtPct(rel * 100)} tipo={tipo} />
        </>
      );
    }

    // ─── VISTAS PyG ───────────────────────────────────────────────────────────

    function PygTable({ hist, real, ppto, titulo }) {
      if (!real) return <div className="text-gray-400 italic text-sm p-4">Sin datos cargados</div>;
      const realC  = calcPygPct(real);
      const histC  = calcPygPct(hist);
      const pptoC  = calcPygPct(ppto);

      return (
        <div className="overflow-x-auto">
          <table className="w-full border-collapse text-sm">
            <thead>
              <tr className="bg-gray-800 text-white">
                <th className="px-3 py-2 text-left w-64">Cuenta de Perdidas y Ganancias</th>
                <th className="px-3 py-2 text-right text-blue-300">{hist ? 'Historico' : ''}</th>
                <th className="px-3 py-2 text-right text-orange-300">Real</th>
                <th className="px-3 py-2 text-right text-green-300">{ppto ? 'Presupuesto' : ''}</th>
                {hist && <><th className="px-3 py-2 text-right text-xs" colSpan={2}>Dif. Real/Hist</th></>}
                {ppto && <><th className="px-3 py-2 text-right text-xs" colSpan={2}>Dif. Real/Ppto</th></>}
              </tr>
              <tr className="bg-gray-700 text-gray-300 text-xs">
                <th className="px-3 py-1">Datos en miles €</th>
                <th className="px-3 py-1 text-right">{hist ? titulo?.hist || '' : ''}</th>
                <th className="px-3 py-1 text-right">{titulo?.real || ''}</th>
                <th className="px-3 py-1 text-right">{ppto ? titulo?.ppto || '' : ''}</th>
                {hist && <><th className="px-3 py-1 text-right">Abs.</th><th className="px-3 py-1 text-right">Rel.</th></>}
                {ppto && <><th className="px-3 py-1 text-right">Abs.</th><th className="px-3 py-1 text-right">Rel.</th></>}
              </tr>
            </thead>
            <tbody>
              {PYG_LINES.map(line => {
                const rv = realC?.[line.key] ?? 0;
                const hv = histC?.[line.key] ?? 0;
                const pv = pptoC?.[line.key] ?? 0;
                const isSubtotal = line.tipo === 'subtotal' || line.tipo === 'total';
                const isPct = line.tipo === 'pct';
                const rowClass = isSubtotal ? 'border-t-2 border-gray-300' : isPct ? 'bg-gray-50' : '';

                return (
                  <tr key={line.key} className={'hover:bg-yellow-50 border-b border-gray-100 ' + rowClass}>
                    <Td value={line.label} tipo={isSubtotal ? 'subtotal' : isPct ? 'pct' : 'label'} align="left" />
                    {hist && <Td value={isPct ? fmtPct(hv*100) : fmt(hv)} tipo={isPct ? 'pct' : 'hist'} />}
                    <Td value={isPct ? fmtPct(rv*100) : fmt(rv)} tipo={isPct ? 'pct' : isSubtotal ? 'subtotal' : 'real'} />
                    {ppto && <Td value={isPct ? fmtPct(pv*100) : fmt(pv)} tipo={isPct ? 'pct' : 'ppto'} />}
                    {hist && !isPct && <TdDif abs={rv - hv} rel={hv !== 0 ? (rv-hv)/Math.abs(hv) : 0} />}
                    {hist && isPct && <><Td value="-" /><Td value="-" /></>}
                    {ppto && !isPct && <TdDif abs={rv - pv} rel={pv !== 0 ? (rv-pv)/Math.abs(pv) : 0} />}
                    {ppto && isPct && <><Td value="-" /><Td value="-" /></>}
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      );
    }

    function PygEvol({ evol, evolHist, evolPpto }) {
      if (!evol) return <div className="text-gray-400 italic text-sm p-4">Sin datos cargados</div>;
      const evolC     = calcPygPct(evol);
      const evolHistC = evolHist ? calcPygPct(evolHist) : null;

      return (
        <div className="overflow-x-auto">
          <table className="w-full border-collapse text-xs">
            <thead>
              <tr className="bg-gray-800 text-white">
                <th className="px-3 py-2 text-left sticky left-0 bg-gray-800 w-52">Cuenta P&G — Evolucion</th>
                {MESES_LABEL.map(m => <th key={m} className="px-2 py-2 text-right text-orange-300 min-w-16">{m}</th>)}
                <th className="px-2 py-2 text-right text-orange-300">TOTAL</th>
              </tr>
            </thead>
            <tbody>
              {PYG_LINES.map(line => {
                const isPct = line.tipo === 'pct';
                const isSubtotal = line.tipo === 'subtotal' || line.tipo === 'total';
                const rowClass = isSubtotal ? 'border-t-2 border-gray-300 bg-gray-50' : '';
                const vals = evolC?.[line.key] || Array(12).fill(0);
                const total = isPct ? null : vals.reduce((a,b) => a+b, 0);

                return (
                  <tr key={line.key} className={'hover:bg-yellow-50 border-b border-gray-100 ' + rowClass}>
                    <td className={'px-3 py-1 text-sm sticky left-0 bg-white ' + (isSubtotal ? 'font-bold bg-gray-50' : isPct ? 'italic text-gray-500' : 'font-medium text-gray-700')}>
                      {line.label}
                    </td>
                    {vals.map((v, i) => (
                      <Td key={i} value={isPct ? fmtPct(v*100) : fmt(v)} tipo={isPct ? 'pct' : 'real'} />
                    ))}
                    <Td value={isPct ? '' : fmt(total)} tipo={isSubtotal ? 'subtotal' : 'real'} />
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      );
    }

    // ─── VISTA BS ─────────────────────────────────────────────────────────────

    function BsTable({ hist, real, ppto, titulo }) {
      if (!real) return <div className="text-gray-400 italic text-sm p-4">Sin datos cargados</div>;
      return (
        <div className="overflow-x-auto">
          <table className="w-full border-collapse text-sm">
            <thead>
              <tr className="bg-gray-800 text-white">
                <th className="px-3 py-2 text-left w-72">Balance de Situacion</th>
                <th className="px-3 py-2 text-right text-blue-300">Historico</th>
                <th className="px-3 py-2 text-right text-orange-300">Real</th>
                {ppto && <th className="px-3 py-2 text-right text-green-300">Presupuesto</th>}
                <th className="px-3 py-2 text-right text-xs" colSpan={2}>Dif. Real/Hist</th>
                {ppto && <th className="px-3 py-2 text-right text-xs" colSpan={2}>Dif. Real/Ppto</th>}
              </tr>
              <tr className="bg-gray-700 text-gray-300 text-xs">
                <th className="px-3 py-1">Datos en miles €</th>
                <th className="px-3 py-1 text-right">{titulo?.hist || ''}</th>
                <th className="px-3 py-1 text-right">{titulo?.real || ''}</th>
                {ppto && <th className="px-3 py-1 text-right">{titulo?.ppto || ''}</th>}
                <th className="px-3 py-1 text-right">Abs.</th>
                <th className="px-3 py-1 text-right">Rel.</th>
                {ppto && <><th className="px-3 py-1 text-right">Abs.</th><th className="px-3 py-1 text-right">Rel.</th></>}
              </tr>
            </thead>
            <tbody>
              {BS_LINES.map(line => {
                const hv = hist?.[line.key] ?? 0;
                const rv = real?.[line.key] ?? 0;
                const pv = ppto?.[line.key] ?? 0;
                const isTop = line.nivel === 0;
                const isSub = line.nivel === 1;
                const rowClass = isTop ? 'bg-gray-200 border-t-2 border-gray-400' : isSub ? 'bg-gray-50 border-t border-gray-200' : '';

                return (
                  <tr key={line.key} className={'hover:bg-yellow-50 border-b border-gray-100 ' + rowClass}>
                    <td className={'px-3 py-1.5 ' + (isTop ? 'font-bold text-gray-900' : isSub ? 'font-semibold text-gray-800' : 'text-gray-700 pl-6')}>
                      {line.label}
                    </td>
                    <Td value={fmt(hv)} tipo="hist" />
                    <Td value={fmt(rv)} tipo={isTop || isSub ? 'subtotal' : 'real'} />
                    {ppto && <Td value={fmt(pv)} tipo="ppto" />}
                    <TdDif abs={rv - hv} rel={hv !== 0 ? (rv-hv)/Math.abs(hv) : 0} positiveIsGood={line.grupo === 'activo'} />
                    {ppto && <TdDif abs={rv - pv} rel={pv !== 0 ? (rv-pv)/Math.abs(pv) : 0} positiveIsGood={line.grupo === 'activo'} />}
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      );
    }

    function BsEvol({ evol, bsHist }) {
      if (!evol) return <div className="text-gray-400 italic text-sm p-4">Sin datos cargados</div>;
      const topLines = BS_LINES.filter(l => l.nivel <= 1);
      return (
        <div className="overflow-x-auto">
          <table className="w-full border-collapse text-xs">
            <thead>
              <tr className="bg-gray-800 text-white">
                <th className="px-3 py-2 text-left sticky left-0 bg-gray-800 w-52">Balance — Evolucion</th>
                <th className="px-2 py-2 text-right text-blue-300 min-w-16">dic-25</th>
                {MESES_LABEL.map(m => <th key={m} className="px-2 py-2 text-right text-orange-300 min-w-16">{m}</th>)}
              </tr>
            </thead>
            <tbody>
              {BS_LINES.map(line => {
                const isTop = line.nivel === 0;
                const isSub = line.nivel === 1;
                const rowClass = isTop ? 'bg-gray-200 border-t-2 border-gray-400' : isSub ? 'bg-gray-50' : '';
                const hv = bsHist?.[line.key] ?? 0;
                const vals = evol?.[line.key] || Array(12).fill(0);
                return (
                  <tr key={line.key} className={'hover:bg-yellow-50 border-b border-gray-100 ' + rowClass}>
                    <td className={'px-3 py-1 sticky left-0 bg-inherit ' + (isTop ? 'font-bold' : isSub ? 'font-semibold' : 'pl-5 text-gray-600')}>
                      {line.label}
                    </td>
                    <Td value={fmt(hv)} tipo="hist" />
                    {vals.map((v, i) => <Td key={i} value={fmt(v)} tipo={isTop || isSub ? 'subtotal' : 'real'} />)}
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      );
    }

    // ─── VISTA CF ─────────────────────────────────────────────────────────────

    const CF_LINES = [
      { key:'ebitdaPF',  label:'EBITDA PF',                            tipo:'subtotal' },
      { key:'noRec',     label:'No recurrentes',                        tipo:'coste' },
      { key:'dtoComercial', label:'Ingresos/Gtos Dto. Comercial',       tipo:'otro' },
      { key:'ebitda',    label:'EBITDA',                               tipo:'subtotal' },
      { key:'dExist',    label:'Existencias',                          tipo:'wc' },
      { key:'dClientes', label:'Clientes',                             tipo:'wc' },
      { key:'dProv',     label:'Proveedores/Acreedores',               tipo:'wc' },
      { key:'dPeriodif', label:'Periodificaciones',                    tipo:'wc' },
      { key:'totalWC',   label:'Total Variacion Circulante',           tipo:'subtotal' },
      { key:'dAAPP',     label:'AAPP',                                 tipo:'otro' },
      { key:'fcOp',      label:'Flujo de caja operativo',              tipo:'total' },
      { key:'capexVal',  label:'Capex',                                tipo:'coste' },
      { key:'fcDisp',    label:'FC disponible para el servicio deuda', tipo:'subtotal' },
      { key:'gtosFin',   label:'Total Gastos/Ingresos Financieros',    tipo:'coste' },
      { key:'fcRepago',  label:'FC disponible para repago deuda',      tipo:'subtotal' },
      { key:'varCaja',   label:'Variacion de Caja',                    tipo:'subtotal' },
      { key:'tesPrev',   label:'Caja BoP',                             tipo:'otro' },
      { key:'tesCurr',   label:'Caja EoP',                             tipo:'total' },
    ];

    function CfTable({ cf, titulo }) {
      if (!cf) return <div className="text-gray-400 italic text-sm p-4">Sin datos o datos insuficientes para calcular CF</div>;
      return (
        <div className="overflow-x-auto">
          <table className="w-full border-collapse text-sm">
            <thead>
              <tr className="bg-gray-800 text-white">
                <th className="px-3 py-2 text-left w-72">Cash Flow</th>
                <th className="px-3 py-2 text-right text-orange-300">{titulo || 'Real'}</th>
              </tr>
              <tr className="bg-gray-700 text-gray-300 text-xs">
                <th className="px-3 py-1">Datos en miles €</th>
                <th className="px-3 py-1 text-right"></th>
              </tr>
            </thead>
            <tbody>
              {CF_LINES.map(line => {
                const v = cf[line.key] ?? 0;
                const isTop = line.tipo === 'total';
                const isSub = line.tipo === 'subtotal';
                const rowClass = isTop ? 'bg-gray-200 border-t-2 border-gray-400' : isSub ? 'bg-gray-50 border-t border-gray-200' : '';
                return (
                  <tr key={line.key} className={'hover:bg-yellow-50 border-b border-gray-100 ' + rowClass}>
                    <td className={'px-3 py-1.5 ' + (isTop ? 'font-bold' : isSub ? 'font-semibold' : 'text-gray-700')}>
                      {line.label}
                    </td>
                    <Td value={fmt(v)} tipo={isTop ? 'total' : isSub ? 'subtotal' : 'real'} />
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      );
    }

    // ─── ZOOM: WC ─────────────────────────────────────────────────────────────

    function WcTable({ bsReal, bsHist }) {
      if (!bsReal) return <div className="text-gray-400 italic text-sm p-4">Sin datos de Balance cargados</div>;
      const wcKeys = [
        { key:'existencias', label:'Existencias' },
        { key:'clientes',    label:'Clientes' },
        { key:'proveedores', label:'Proveedores' },
      ];
      function wcTotal(m) {
        return (bsReal.existencias?.[m]||0) + (bsReal.clientes?.[m]||0) - (bsReal.proveedores?.[m]||0);
      }
      const histWC = (bsHist?.existencias||0) + (bsHist?.clientes||0) - (bsHist?.proveedores||0);

      return (
        <div className="overflow-x-auto">
          <table className="w-full border-collapse text-xs">
            <thead>
              <tr className="bg-gray-800 text-white">
                <th className="px-3 py-2 text-left sticky left-0 bg-gray-800">Capital Circulante</th>
                <th className="px-2 py-2 text-right text-blue-300">dic-25</th>
                {MESES_LABEL.map(m => <th key={m} className="px-2 py-2 text-right text-orange-300 min-w-16">{m}</th>)}
              </tr>
            </thead>
            <tbody>
              {wcKeys.map(wc => (
                <tr key={wc.key} className="hover:bg-yellow-50 border-b border-gray-100">
                  <td className="px-3 py-1 sticky left-0 bg-white font-medium text-gray-700">{wc.label}</td>
                  <Td value={fmt(bsHist?.[wc.key] || 0)} tipo="hist" />
                  {(bsReal[wc.key] || Array(12).fill(0)).map((v,i) => <Td key={i} value={fmt(v)} tipo="real" />)}
                </tr>
              ))}
              <tr className="bg-gray-100 border-t-2 border-gray-300 font-bold">
                <td className="px-3 py-1.5 sticky left-0 bg-gray-100 font-bold text-gray-900">Capital Circulante (Exist+Cli-Prov)</td>
                <Td value={fmt(histWC)} tipo="hist" />
                {MESES.map((_, i) => <Td key={i} value={fmt(wcTotal(i))} tipo="subtotal" />)}
              </tr>
            </tbody>
          </table>
        </div>
      );
    }

    // ─── ZOOM GENERICO (NoRec, OPEX, CAPEX, DFN) ──────────────────────────────

    function ZoomTable({ data, title }) {
      if (!data || Object.keys(data).length === 0)
        return <div className="text-gray-400 italic text-sm p-4">Sin datos cargados</div>;
      const keys = Object.keys(data);
      return (
        <div className="overflow-x-auto">
          <table className="w-full border-collapse text-xs">
            <thead>
              <tr className="bg-gray-800 text-white">
                <th className="px-3 py-2 text-left sticky left-0 bg-gray-800 min-w-48">{title}</th>
                {MESES_LABEL.map(m => <th key={m} className="px-2 py-2 text-right text-orange-300 min-w-16">{m}</th>)}
                <th className="px-2 py-2 text-right text-orange-300">YTD</th>
              </tr>
            </thead>
            <tbody>
              {keys.map(k => {
                const vals = data[k] || Array(12).fill(0);
                const total = vals.reduce((a,b) => a+b, 0);
                return (
                  <tr key={k} className="hover:bg-yellow-50 border-b border-gray-100">
                    <td className="px-3 py-1 sticky left-0 bg-white text-gray-700">{k}</td>
                    {vals.map((v,i) => <Td key={i} value={v !== 0 ? fmt(v) : '-'} tipo="real" />)}
                    <Td value={fmt(total)} tipo="subtotal" />
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      );
    }

    // ─── ZOOM NO RECURRENTES ───────────────────────────────────────────────────

    function ZoomNoRec({ data }) {
      if (!data?.reales && !data?.presupuesto)
        return <div className="text-gray-400 italic text-sm p-4">Sin datos cargados</div>;

      function renderBlock(block, title, headerColor) {
        if (!block?.rows?.length) return null;
        return (
          <div className="mb-8">
            <div className={'px-4 py-2 font-bold text-sm rounded-t ' + headerColor}>{title}</div>
            <div className="overflow-x-auto">
              <table className="w-full border-collapse text-xs">
                <thead>
                  <tr className="bg-gray-800 text-white">
                    <th className="px-3 py-2 text-left sticky left-0 bg-gray-800 min-w-52"></th>
                    {MESES_LABEL.map(m => <th key={m} className="px-2 py-2 text-right text-orange-300 min-w-16">{m}</th>)}
                    <th className="px-2 py-2 text-right text-orange-300">YTD</th>
                  </tr>
                </thead>
                <tbody>
                  {block.rows.map((row, i) => {
                    const total = row.vals.reduce((a, b) => a + b, 0);
                    const isTotal    = row.tipo === 'total';
                    const isSubtotal = row.tipo === 'subtotal';
                    const rowBg   = isTotal    ? 'bg-gray-200 border-t-2 border-gray-500'
                                  : isSubtotal ? 'bg-gray-100 border-t border-gray-300'
                                  : 'hover:bg-yellow-50 border-b border-gray-100';
                    const labelBg = isTotal    ? 'bg-gray-200 font-bold text-gray-900'
                                  : isSubtotal ? 'bg-gray-100 font-semibold text-gray-800'
                                  : 'bg-white text-gray-600';
                    return (
                      <tr key={i} className={rowBg}>
                        <td className={'px-3 py-1 sticky left-0 ' + labelBg + ((!isTotal && !isSubtotal) ? ' pl-6' : '')}>
                          {row.label}
                        </td>
                        {row.vals.map((v, j) => <Td key={j} value={v !== 0 ? fmt(v) : '-'} tipo={isTotal ? 'total' : isSubtotal ? 'subtotal' : 'real'} />)}
                        <Td value={fmt(total)} tipo={isTotal ? 'total' : 'subtotal'} />
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        );
      }

      return (
        <div>
          {renderBlock(data.reales,      'Gastos no recurrentes — REAL',        'bg-orange-100 text-orange-800')}
          {renderBlock(data.presupuesto, 'Gastos no recurrentes — PRESUPUESTO', 'bg-green-100 text-green-800')}
        </div>
      );
    }

    // ─── PARSERS DE PLANTILLA ─────────────────────────────────────────────────
    // Plantillas generadas por la app: fila 0 = cabecera, col 0 = "CONCEPTO"

    function isTemplateFmt(rows) {
      return String(rows?.[0]?.[0] || '').trim().toUpperCase() === 'CONCEPTO';
    }

    // PyG: col 0 = label exacto, cols 1..12 = valores mensuales
    function parsePygTpl(rows) {
      const labelMap = {};
      PYG_LINES.forEach(l => { labelMap[l.label.toLowerCase()] = l.key; });
      const result = {};
      for (let r = 1; r < rows.length; r++) {
        const label = String(rows[r][0] || '').trim();
        if (!label) continue;
        const key = labelMap[label.toLowerCase()] || matchPygLine(label);
        if (!key) continue;
        result[key] = Array.from({ length: 12 }, (_, i) => parseNum(rows[r][i + 1]));
      }
      return Object.keys(result).length > 0 ? result : null;
    }

    // BS: detecta si hay col hist (col 1 empieza por "dic") o no
    // Soporta tres formatos:
    //   1. Plantilla app: A1="CONCEPTO", col A = labels exactos de BS_LINES
    //   2. Fuzzy: col A = labels con variantes de escritura (matchBsLine)
    //   3. Posicional: col A = cualquier cosa, pero hay exactamente BS_LINES.length filas de datos
    function parseBsTpl(rows) {
      const labelMap = {};
      BS_LINES.forEach(l => { labelMap[l.label.toLowerCase()] = l.key; });

      const header = rows[0] || [];
      const col1 = String(header[1] || '').toLowerCase().trim();
      const hasHist = col1.startsWith('dic');
      const offset = hasHist ? 1 : 0;
      const hist = {};
      const real = {};
      BS_LINES.forEach(l => { hist[l.key] = 0; real[l.key] = Array(12).fill(0); });
      let matched = 0;

      // Intentar por label (exacto o fuzzy)
      for (let r = 1; r < rows.length; r++) {
        const label = String(rows[r][0] || '').trim();
        if (!label) continue;
        const key = labelMap[label.toLowerCase()] || matchBsLine(label);
        if (!key) continue;
        matched++;
        if (hasHist) hist[key] = parseNum(rows[r][1]);
        real[key] = Array.from({ length: 12 }, (_, i) => parseNum(rows[r][i + 1 + offset]));
      }

      // Fallback posicional: si no se reconocio ningun label pero hay exactamente
      // BS_LINES.length filas de datos, leer por posicion (fila N → BS_LINES[N])
      if (matched === 0) {
        const dataRows = rows.slice(1).filter(r => (r || []).length >= 12);
        if (dataRows.length === BS_LINES.length) {
          dataRows.forEach((row, idx) => {
            const key = BS_LINES[idx].key;
            if (hasHist) hist[key] = parseNum(row[1]);
            real[key] = Array.from({ length: 12 }, (_, i) => parseNum(row[i + 1 + offset]));
            matched++;
          });
        }
      }

      return matched > 0 ? { hist, real } : null;
    }

    // Simple (OPEX/CAPEX/DFN/NoRec): col 0 = label libre, cols 1..12 = valores
    function parseSimpleTpl(rows) {
      const result = {};
      for (let r = 1; r < rows.length; r++) {
        const label = String(rows[r][0] || '').trim();
        if (!label) continue;
        result[label] = Array.from({ length: 12 }, (_, i) => parseNum(rows[r][i + 1]));
      }
      return Object.keys(result).length > 0 ? result : null;
    }

    // ─── PANTALLA DE CONFIGURACION ─────────────────────────────────────────────

    function ConfigScreen({ data, onLoad, onClear }) {
      const configItems = [
        { key:'pygHist',   label:'PyG Historico 2025 (ene-25 a dic-25)',  color:'blue',   sheet:'PyG', mesLabels: MESES_HIST },
        { key:'pygPpto',   label:'PyG Presupuesto 2026 (ene-26 a dic-26)', color:'green',  sheet:'PyG', mesLabels: MESES_LABEL },
        { key:'bsHist',    label:'BS Historico (cierre dic-25)',           color:'blue',   sheet:'BS',  type:'bs' },
        { key:'bsPpto',    label:'BS Presupuesto 2026 (mensual)',          color:'green',  sheet:'BS',  type:'bs' },
        { key:'opexHist',  label:'OPEX Historico 2025',                   color:'blue',   sheet:'OPEX', mesLabels: MESES_HIST },
        { key:'opexPpto',  label:'OPEX Presupuesto 2026',                 color:'green',  sheet:'OPEX', mesLabels: MESES_LABEL },
      ];

      const monthlyItems = [
        { key:'pygReal',   label:'PyG Real/Estimado 2026 — Evol mensual', color:'orange', sheet:'PyG', mesLabels: MESES_LABEL },
        { key:'bsReal',    label:'BS Real 2026 — Evol mensual',           color:'orange', sheet:'BS',  type:'bs' },
        { key:'norecReal', label:'No Recurrentes Real 2026',              color:'orange', sheet:'NoRec', mesLabels: MESES_LABEL },
        { key:'opexReal',  label:'OPEX Real 2026',                        color:'orange', sheet:'OPEX', mesLabels: MESES_LABEL },
        { key:'capexReal', label:'CAPEX Real 2026',                       color:'orange', sheet:'CAPEX', mesLabels: MESES_LABEL },
        { key:'dfnReal',   label:'DFN Real 2026',                         color:'orange', sheet:'DFN',  mesLabels: MESES_LABEL },
      ];

      function handleLoaded(wb, storageKey) {
        const item = [...configItems, ...monthlyItems].find(i => i.key === storageKey);
        if (!item) return;
        let parsed = null;

        if (item.type === 'bs') {
          // Busca la mejor hoja BS disponible
          const bsEvol = wb.SheetNames.find(n => /bs.?evol/i.test(n));
          const bsAny  = wb.SheetNames.find(n => /bs/i.test(n));
          const sheetName = bsEvol || bsAny || wb.SheetNames[0];
          const ws0  = wb.Sheets[sheetName];
          const rows0 = ws0 ? sheetToArray(ws0) : [];
          const isTpl = isTemplateFmt(rows0)
            || (rows0.length === BS_LINES.length + 1 && (rows0[0]?.length || 0) >= 12);
          const raw = isTpl ? parseBsTpl(rows0) : parseBsEvol(wb, sheetName);
          if (!raw) {
            alert('No se pudo leer el Balance.\nHoja: "' + sheetName + '".\n' +
                  (isTpl ? 'La plantilla no contiene lineas reconocidas de BS.'
                          : 'Revisa que el archivo tenga columnas de meses.'));
            return;
          }
          if (storageKey === 'bsHist') {
            if (isTpl) {
              // Si la plantilla tiene columna "dic" hist → raw.hist tiene los datos
              // Si la plantilla solo tiene 12 meses (sin col hist) → tomar el mes dic (indice 11)
              const hasHistVals = Object.values(raw.hist || {}).some(v => v !== 0);
              parsed = hasHistVals
                ? raw.hist
                : Object.fromEntries(BS_LINES.map(l => [l.key, raw.real?.[l.key]?.[11] ?? 0]));
            } else {
              // Archivo legacy: usar el ultimo mes de real como snapshot dic-25
              const realArrays = Object.values(raw.real || {}).filter(Array.isArray);
              const lastMes = realArrays.length > 0 ? realArrays[0].length - 1 : -1;
              parsed = lastMes >= 0
                ? Object.fromEntries(BS_LINES.map(l => [l.key, raw.real?.[l.key]?.[lastMes] ?? raw.hist?.[l.key] ?? 0]))
                : raw.hist;
            }
          } else if (storageKey === 'bsPpto') {
            parsed = raw.real;
          } else {
            parsed = raw;
          }
        } else {
          let sheetName;
          // Para PyG: preferir siempre la hoja Evol (12 meses), no la MES ni YTD
          if (item.key.startsWith('pyg')) {
            sheetName = wb.SheetNames.find(n => /pyg.?evol/i.test(n))
                     || wb.SheetNames.find(n => /pyg/i.test(n) && !/mes|ytd|ahl|vtz|alm/i.test(n))
                     || wb.SheetNames.find(n => /pyg/i.test(n))
                     || wb.SheetNames[0];
          } else if (item.key.startsWith('norec')) {
            sheetName = wb.SheetNames.find(n => /no.?rec/i.test(n) || /recurrente/i.test(n))
                     || wb.SheetNames[0];
          } else if (item.key.startsWith('opex')) {
            sheetName = wb.SheetNames.find(n => /opex/i.test(n) || /explotaci/i.test(n))
                     || wb.SheetNames[0];
          } else if (item.key.startsWith('capex')) {
            sheetName = wb.SheetNames.find(n => /capex/i.test(n)) || wb.SheetNames[0];
          } else if (item.key.startsWith('dfn')) {
            sheetName = wb.SheetNames.find(n => /dfn/i.test(n) || /deuda/i.test(n)) || wb.SheetNames[0];
          } else {
            sheetName = wb.SheetNames.includes(item.sheet)
              ? item.sheet
              : wb.SheetNames.find(n => n.toLowerCase().includes(item.sheet.toLowerCase()))
              || wb.SheetNames[0];
          }
          const ws1  = wb.Sheets[sheetName];
          const rows1 = ws1 ? sheetToArray(ws1) : [];
          const isTpl = isTemplateFmt(rows1);
          if (isTpl) {
            if (item.key.startsWith('pyg')) {
              parsed = parsePygTpl(rows1);
            } else {
              parsed = parseSimpleTpl(rows1);
            }
          } else if (item.key.includes('norec')) {
            parsed = parseNoRecSheet(wb, sheetName, item.mesLabels);
          } else if (item.key.includes('opex') || item.key.includes('capex') || item.key.includes('dfn')) {
            parsed = parseMonthlySheet(wb, sheetName, item.mesLabels);
          } else {
            parsed = parsePygEvol(wb, sheetName, item.mesLabels);
          }
        }

        if (!parsed || (typeof parsed === 'object' && Object.keys(parsed).length === 0)) {
          alert('No se pudo leer el archivo. Hoja buscada: "' + item.sheet + '".\nHojas encontradas: ' + wb.SheetNames.join(', '));
          return;
        }
        saveToStorage(STORAGE_KEYS[storageKey], parsed);
        onLoad(storageKey, parsed);
      }

      function handleDownloadTemplate(storageKey) {
        const t = getTemplate(storageKey);
        if (t) downloadXlsx(t.wb, t.name);
      }

      return (
        <div className="space-y-6">
          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <h3 className="font-bold text-blue-800 mb-3">Configuracion (subida unica — se guarda en el navegador)</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
              {configItems.map(item => (
                <UploadButton key={item.key} label={item.label} storageKey={item.key}
                  color={item.color} loaded={!!data[item.key]} onLoaded={handleLoaded}
                  onDownloadTemplate={handleDownloadTemplate} />
              ))}
            </div>
          </div>

          <div className="bg-orange-50 border border-orange-200 rounded-lg p-4">
            <h3 className="font-bold text-orange-800 mb-3">Datos mensuales (actualizar cada mes)</h3>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
              {monthlyItems.map(item => (
                <UploadButton key={item.key} label={item.label} storageKey={item.key}
                  color={item.color} loaded={!!data[item.key]} onLoaded={handleLoaded}
                  onDownloadTemplate={handleDownloadTemplate} />
              ))}
            </div>
          </div>

          {/* Resumen de datos cargados */}
          {Object.values(data).some(Boolean) && (
            <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
              <h3 className="font-bold text-gray-700 mb-2 text-sm">Verificacion de datos cargados</h3>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                {data.pygReal && (
                  <div className="bg-white border rounded p-2">
                    <div className="text-gray-500">PyG Real — Ventas ene-26</div>
                    <div className={'font-bold ' + (data.pygReal.ventas?.[0] > 0 && data.pygReal.ventas?.[0] < 999999 ? 'text-green-700' : 'text-red-600')}>
                      {data.pygReal.ventas?.[0] != null ? data.pygReal.ventas[0].toFixed(0) : 'N/A'}
                    </div>
                    <div className="text-gray-400">EBITDA: {data.pygReal.ebitda?.[0]?.toFixed(0) ?? 'N/A'}</div>
                  </div>
                )}
                {data.pygHist && (
                  <div className="bg-white border rounded p-2">
                    <div className="text-gray-500">PyG Hist — Ventas ene-25</div>
                    <div className={'font-bold ' + (data.pygHist.ventas?.[0] > 0 && data.pygHist.ventas?.[0] < 999999 ? 'text-green-700' : 'text-red-600')}>
                      {data.pygHist.ventas?.[0] != null ? data.pygHist.ventas[0].toFixed(0) : 'N/A'}
                    </div>
                  </div>
                )}
                {data.pygPpto && (
                  <div className="bg-white border rounded p-2">
                    <div className="text-gray-500">PyG Ppto — Ventas ene-26</div>
                    <div className={'font-bold ' + (data.pygPpto.ventas?.[0] > 0 && data.pygPpto.ventas?.[0] < 999999 ? 'text-green-700' : 'text-red-600')}>
                      {data.pygPpto.ventas?.[0] != null ? data.pygPpto.ventas[0].toFixed(0) : 'N/A'}
                    </div>
                  </div>
                )}
                {data.bsReal && (
                  <div className="bg-white border rounded p-2">
                    <div className="text-gray-500">BS — Activo ene-26</div>
                    <div className={'font-bold ' + (data.bsReal.real?.activo?.[0] > 0 ? 'text-green-700' : 'text-red-600')}>
                      {data.bsReal.real?.activo?.[0]?.toFixed(0) ?? 'N/A'}
                    </div>
                  </div>
                )}
                {data.bsHist && (
                  <div className="bg-white border rounded p-2">
                    <div className="text-gray-500">BS Hist — Activo dic-25</div>
                    <div className={'font-bold ' + (data.bsHist.activo > 0 ? 'text-green-700' : 'text-red-600')}>
                      {data.bsHist.activo != null ? data.bsHist.activo.toFixed(0) : 'N/A'}
                    </div>
                  </div>
                )}
              </div>
              <p className="text-xs text-gray-400 mt-2">Los valores deben estar en miles de euros (rango esperado: 100 — 999.999). Si aparecen en rojo, borra y vuelve a subir.</p>
            </div>
          )}

          <div className="bg-red-50 border border-red-200 rounded-lg p-3">
            <div className="flex items-center justify-between">
              <span className="text-sm text-red-700">Borrar todos los datos guardados en este navegador</span>
              <button onClick={onClear}
                className="text-sm bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700">
                Borrar todo
              </button>
            </div>
          </div>
        </div>
      );
    }

    // ─── APP PRINCIPAL ─────────────────────────────────────────────────────────

    function App() {
      const [seccion, setSeccion] = useState('config');
      const [mesActivo, setMesActivo] = useState(0); // 0=ene, 11=dic
      const [empresa, setEmpresa] = useState('Consolidado');
      const [tabPyg, setTabPyg] = useState('MES');
      const [tabBs, setTabBs]   = useState('YTD');
      const [tabCf, setTabCf]   = useState('MES');
      const [tabZoom, setTabZoom] = useState('NoRec');

      // Estado de datos
      const [appData, setAppData] = useState(() => {
        const d = {};
        Object.entries(STORAGE_KEYS).forEach(([k, sk]) => { d[k] = loadFromStorage(sk); });
        return d;
      });

      function handleLoad(key, parsed) {
        setAppData(prev => ({ ...prev, [key]: parsed }));
      }

      function handleClearAll() {
        if (!confirm('Borrar todos los datos guardados. Esta accion no se puede deshacer.')) return;
        Object.values(STORAGE_KEYS).forEach(sk => clearStorage(sk));
        setAppData({});
      }

      // PyG real ajustado con No Recurrentes (opex+personal+no_rec+subtotales recalculados)
      const adjPygReal = getAdjustedPygReal(appData.pygReal, appData.norecReal);

      // Datos derivados para el mes activo
      const pygRealMes  = adjPygReal   ? Object.fromEntries(PYG_LINES.map(l => [l.key, adjPygReal?.[l.key]?.[mesActivo] ?? 0])) : null;
      const pygHistMes  = appData.pygHist  ? Object.fromEntries(PYG_LINES.map(l => [l.key, appData.pygHist?.[l.key]?.[mesActivo] ?? 0])) : null;
      const pygPptoMes  = appData.pygPpto  ? Object.fromEntries(PYG_LINES.map(l => [l.key, appData.pygPpto?.[l.key]?.[mesActivo] ?? 0])) : null;

      // YTD: suma de ene hasta mes activo
      const pygRealYTD  = adjPygReal   ? Object.fromEntries(PYG_LINES.map(l => [l.key, ytd(adjPygReal?.[l.key], mesActivo)])) : null;
      const pygHistYTD  = appData.pygHist  ? Object.fromEntries(PYG_LINES.map(l => [l.key, ytd(appData.pygHist?.[l.key], mesActivo)])) : null;
      const pygPptoYTD  = appData.pygPpto  ? Object.fromEntries(PYG_LINES.map(l => [l.key, ytd(appData.pygPpto?.[l.key], mesActivo)])) : null;

      // BS YTD: valor del mes activo
      const bsRealMes   = appData.bsReal?.real  ? Object.fromEntries(BS_LINES.map(l => [l.key, appData.bsReal.real?.[l.key]?.[mesActivo] ?? 0])) : null;
      // bsHistData: snapshot historico dic-25.
      // Prioridad: bsHist cargado explicitamente > bsReal.hist derivado del archivo evol.
      const bsHistData = (() => {
        if (appData.bsHist && Object.values(appData.bsHist).some(v => v !== 0)) return appData.bsHist;
        const h = appData.bsReal?.hist;
        if (h && Object.values(h).some(v => v !== 0)) return h;
        return null;
      })();
      const bsHistMes   = bsHistData;
      // bsPpto se guarda como raw.real (objeto plano { key: [v1..v12] }), sin wrapper .real
      const bsPptoMes   = appData.bsPpto ? Object.fromEntries(BS_LINES.map(l => [l.key, appData.bsPpto?.[l.key]?.[mesActivo] ?? 0])) : null;

      // CF mes
      const cfMes = calcCF(adjPygReal, appData.bsReal?.real, bsHistData, appData.capexReal, appData.dfnReal, mesActivo);

      // CF YTD (suma mes a mes)
      function cfYtd() {
        if (!adjPygReal || !appData.bsReal?.real) return null;
        const cfArr = MESES.map((_, m) => calcCF(adjPygReal, appData.bsReal?.real, bsHistData, appData.capexReal, appData.dfnReal, m));
        const sum = {};
        CF_LINES.forEach(l => { sum[l.key] = cfArr.slice(0, mesActivo+1).reduce((a, cf) => a + (cf?.[l.key] || 0), 0); });
        // Caja EoP y BoP no se suman, son valores de stock
        if (cfMes) { sum.tesCurr = cfMes.tesCurr; sum.tesPrev = cfArr[0]?.tesPrev || 0; }
        return sum;
      }

      const mesLabel = MESES_LABEL[mesActivo];
      const dataLoaded = !!appData.pygReal;

      const SECCIONES = [
        { id:'config', label:'Configuracion' },
        { id:'pyg',    label:'PyG' },
        { id:'bs',     label:'Balance' },
        { id:'cf',     label:'Cash Flow' },
        { id:'zoom',   label:'Detalle' },
      ];

      return (
        <div className="min-h-screen bg-gray-100">
          {/* Header */}
          <div className="bg-gray-900 text-white px-6 py-3 flex items-center justify-between shadow-lg">
            <div className="flex items-center gap-4">
              <span className="font-bold text-lg tracking-wide">REPORTING AGROSANA</span>
              <span className="text-gray-400 text-sm">2026</span>
            </div>
            <div className="flex items-center gap-4">
              {/* Selector de mes */}
              <div className="flex items-center gap-2">
                <span className="text-gray-400 text-sm">Periodo:</span>
                <select value={mesActivo} onChange={e => setMesActivo(Number(e.target.value))}
                  className="bg-gray-700 text-white border border-gray-600 rounded px-2 py-1 text-sm">
                  {MESES_LABEL.map((m,i) => <option key={i} value={i}>{m}</option>)}
                </select>
              </div>
              {/* Selector empresa */}
              <div className="flex items-center gap-2">
                <span className="text-gray-400 text-sm">Empresa:</span>
                <select value={empresa} onChange={e => setEmpresa(e.target.value)}
                  className="bg-gray-700 text-white border border-gray-600 rounded px-2 py-1 text-sm">
                  {EMPRESAS.map(e => <option key={e} value={e}>{e}</option>)}
                </select>
              </div>
              {/* Estado de carga */}
              {dataLoaded
                ? <Badge color="green">Datos cargados</Badge>
                : <Badge color="red">Sin datos</Badge>}
            </div>
          </div>

          {/* Nav */}
          <div className="bg-white shadow-sm border-b border-gray-200 px-6">
            <div className="flex gap-0">
              {SECCIONES.map(s => (
                <button key={s.id} onClick={() => setSeccion(s.id)}
                  className={'px-5 py-3 text-sm font-medium border-b-2 transition-colors ' +
                    (seccion === s.id
                      ? 'border-blue-600 text-blue-700'
                      : 'border-transparent text-gray-500 hover:text-gray-700')}>
                  {s.label}
                </button>
              ))}
            </div>
          </div>

          {/* Contenido */}
          <div className="p-6 max-w-screen-xl mx-auto">
            {seccion === 'config' && (
              <div>
                <SectionTitle>Configuracion y carga de datos</SectionTitle>
                <ConfigScreen data={appData} onLoad={handleLoad} onClear={handleClearAll} />
              </div>
            )}

            {seccion === 'pyg' && (
              <div>
                <div className="flex items-center justify-between mb-4">
                  <SectionTitle>Cuenta de Perdidas y Ganancias — {empresa}</SectionTitle>
                </div>
                <TabBar tabs={['MES','YTD','EVOL']} active={tabPyg} onChange={setTabPyg} />
                {tabPyg === 'MES' && <PygTable
                  hist={pygHistMes} real={pygRealMes} ppto={pygPptoMes}
                  titulo={{ hist: MESES_HIST[mesActivo], real: mesLabel, ppto: mesLabel }} />}
                {tabPyg === 'YTD' && <PygTable
                  hist={pygHistYTD} real={pygRealYTD} ppto={pygPptoYTD}
                  titulo={{ hist: 'YTD ' + MESES_HIST[mesActivo], real: 'YTD ' + mesLabel, ppto: 'YTD ' + mesLabel }} />}
                {tabPyg === 'EVOL' && <PygEvol evol={adjPygReal} evolHist={appData.pygHist} evolPpto={appData.pygPpto} />}
              </div>
            )}

            {seccion === 'bs' && (
              <div>
                <div className="flex items-center justify-between mb-4">
                  <SectionTitle>Balance de Situacion — {empresa}</SectionTitle>
                </div>
                <TabBar tabs={['YTD','EVOL']} active={tabBs} onChange={setTabBs} />
                {tabBs === 'YTD' && <BsTable
                  hist={bsHistMes} real={bsRealMes} ppto={bsPptoMes}
                  titulo={{ hist: 'dic-25', real: mesLabel, ppto: mesLabel }} />}
                {tabBs === 'EVOL' && <BsEvol evol={appData.bsReal?.real} bsHist={bsHistData} />}
              </div>
            )}

            {seccion === 'cf' && (
              <div>
                <div className="flex items-center justify-between mb-4">
                  <SectionTitle>Cash Flow — {empresa}</SectionTitle>
                </div>
                <TabBar tabs={['MES','YTD']} active={tabCf} onChange={setTabCf} />
                {tabCf === 'MES' && <CfTable cf={cfMes} titulo={'Mes ' + mesLabel} />}
                {tabCf === 'YTD' && <CfTable cf={cfYtd()} titulo={'YTD ' + mesLabel} />}
              </div>
            )}

            {seccion === 'zoom' && (
              <div>
                <SectionTitle>Detalle — {empresa}</SectionTitle>
                <TabBar tabs={['NoRec','OPEX','CAPEX','DFN','WC']} active={tabZoom} onChange={setTabZoom} />
                {tabZoom === 'NoRec'  && <ZoomNoRec data={appData.norecReal} />}
                {tabZoom === 'OPEX'   && <ZoomTable data={appData.opexReal}  title="OPEX Real" />}
                {tabZoom === 'CAPEX'  && <ZoomTable data={appData.capexReal} title="CAPEX Real" />}
                {tabZoom === 'DFN'    && <ZoomTable data={appData.dfnReal}   title="Deuda Financiera Neta" />}
                {tabZoom === 'WC'     && <WcTable   bsReal={appData.bsReal?.real} bsHist={bsHistData} />}
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
